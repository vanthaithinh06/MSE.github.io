// --- Import c√°c th∆∞ vi·ªán CJS (d√πng require) ---
const express = require('express');
const cors = require('cors');
const multer = require('multer');
const dotenv = require('dotenv');
const pdf = require('pdf-parse');
const mammoth = require('mammoth');
const { createClient } = require('@supabase/supabase-js');
const mqtt = require('mqtt'); // üîå Th∆∞ vi·ªán MQTT Client

dotenv.config();

// --- B·ªçc to√†n b·ªô m√°y ch·ªß trong m·ªôt h√†m async ƒë·ªÉ d√πng "await import()" ---
async function startServer() {

  // üî• Import th∆∞ vi·ªán @google/genai v1
  const { GoogleGenAI } = await import('@google/genai');

  const app = express();
  const port = 3001;

  // --- Middleware ---
  app.use(cors());
  app.use(express.json());

  // --- C·∫•u h√¨nh multer ƒë·ªÉ x·ª≠ l√Ω file upload trong b·ªô nh·ªõ ---
  const storage = multer.memoryStorage();
  const upload = multer({ storage });

  // --- C·∫•u h√¨nh Supabase ---
  const supabase = createClient(
    process.env.SUPABASE_URL,
    process.env.SUPABASE_SERVICE_KEY
  );

  // --- Kh·ªüi t·∫°o Clients v·ªõi @google/genai v1 ---
  const genAI = new GoogleGenAI({
    apiKey: process.env.GEMINI_API_KEY
  });

  /* ==========================================================
     üîå C·∫§U H√åNH MQTT CLIENT (CH·∫æ ƒê·ªò K√âP: TEST & HIVEMQ)
  ========================================================== */
  
  // üëá CHUY·ªÇN TH√ÄNH 'true' N·∫æU B·∫†N MU·ªêN D√ôNG HIVEMQ C·ª¶A B·∫†Nvbox/may1/json_data
  // üëá ƒê·ªÇ 'false' ƒê·ªÇ D√ôNG SERVER TEST C√îNG C·ªòNG (KH√îNG C·∫¶N PASS, KH√îNG B·ªä L·ªñI)
  const USE_HIVEMQ_CLOUD = true; 

  let mqttOptions = {};
  let MQTT_HOST = '';
  const MQTT_TOPIC_DATA = 'vbox/may1/json_data';

  if (USE_HIVEMQ_CLOUD) {
      // --- CH·∫æ ƒê·ªò 1: HIVEMQ CLOUD (C·∫ßn ƒëi·ªÅn User/Pass th·∫≠t) ---
      MQTT_HOST = 'f09366560f10477aaa3755efd93d402b.s1.eu.hivemq.cloud'; 
      mqttOptions = {
        port: 8883,
        protocol: 'mqtts',
        username: 'Jin_Luan1', 
        password: '2196_Luan', 
        rejectUnauthorized: true,
        reconnectPeriod: 2000,
      };
      console.log(`üîå ƒêang ch·∫°y ch·∫ø ƒë·ªô: HIVEMQ CLOUD (SSL)...`);
  } else {
      // --- CH·∫æ ƒê·ªò 2: PUBLIC TEST (D√πng test.mosquitto.org) ---
      // Ch·∫°y ngay l·∫≠p t·ª©c, kh√¥ng l·ªói Auth
      MQTT_HOST = 'test.mosquitto.org';
      mqttOptions = {
        port: 8883, // C·ªïng SSL c√¥ng c·ªông
        protocol: 'mqtts',
        rejectUnauthorized: false,
        reconnectPeriod: 2000,
      };
      console.log(`üîå ƒêang ch·∫°y ch·∫ø ƒë·ªô: PUBLIC TEST (Mosquitto SSL)...`);
  }

  // Kh·ªüi t·∫°o k·∫øt n·ªëi
  const mqttClient = mqtt.connect(`mqtts://${MQTT_HOST}`, mqttOptions);

  /* ==========================================================
     üß† LOGIC: PH√ÅT HI·ªÜN THAY ƒê·ªîI D·ªÆ LI·ªÜU (CHANGE DETECTION)
  ========================================================== */
  
  let lastKnownState = { A: null, P: null, Q: null };

  function hasDataChanged(newData, oldData) {
    if (oldData.A === null) return true; // L·∫ßn ƒë·∫ßu ti√™n
    const tolerance = 0.1; // Ng∆∞·ª°ng thay ƒë·ªïi 0.1%
    const diffA = Math.abs(newData.A - oldData.A);
    const diffP = Math.abs(newData.P - oldData.P);
    const diffQ = Math.abs(newData.Q - oldData.Q);
    return (diffA > tolerance || diffP > tolerance || diffQ > tolerance);
  }

  // --- MQTT EVENT: K·∫æT N·ªêI TH√ÄNH C√îNG ---
  mqttClient.on('connect', () => {
    console.log(`‚úÖ MQTT Connected: ${MQTT_HOST}`);
    mqttClient.subscribe(MQTT_TOPIC_DATA, (err) => {
      if (!err) console.log(`üì° ƒêang l·∫Øng nghe topic: "${MQTT_TOPIC_DATA}"`);
    });
  });

  // --- MQTT EVENT: L·ªñI (B√°o user n·∫øu sai pass) ---
  mqttClient.on('error', (err) => {
    console.error('‚ùå MQTT Error:', err.message);
    if (err.message.includes('authorized')) {
        console.error('üëâ L·ªói quy·ªÅn truy c·∫≠p! H√£y ki·ªÉm tra l·∫°i User/Pass ho·∫∑c chuy·ªÉn USE_HIVEMQ_CLOUD = false.');
    }
  });

  // --- MQTT EVENT: NH·∫¨N TIN NH·∫ÆN & L∆ØU DB ---
  mqttClient.on('message', async (topic, message) => {
    try {
      if (topic === MQTT_TOPIC_DATA) {
        const data = JSON.parse(message.toString());

        // Ki·ªÉm tra h·ª£p l·ªá
        if (data.A !== undefined && data.P !== undefined && data.Q !== undefined) {
            
            // Ch·ªâ l∆∞u n·∫øu d·ªØ li·ªáu thay ƒë·ªïi (Tr√°nh spam DB)
            if (hasDataChanged(data, lastKnownState)) {
                console.log(`‚ö° IoT Data Changed: A=${data.A}, P=${data.P}, Q=${data.Q}`);
                lastKnownState = { A: data.A, P: data.P, Q: data.Q };

                console.log('üíæ Saving to Supabase (OEE_Data)...');
                const { error } = await supabase.from('OEE_Data').insert([{
                    'A (%)': parseFloat(data.A),
                    'P (%)': parseFloat(data.P),
                    'Q (%)': parseFloat(data.Q),
                    'Timestamp': new Date().toISOString()
                }]);

                if (error) console.error('‚ùå Supabase Error:', error.message);
                else console.log('‚úÖ Saved!');
            }
        }
      }
    } catch (e) {
      // B·ªè qua l·ªói parse JSON r√°c
    }
  });

  /* ==========================================================
     üîπ C√ÅC H√ÄM H·ªñ TR·ª¢ AI (GEMINI)
  ========================================================== */

  async function listAvailableModels() {
    // Ch·ªâ in log ng·∫Øn g·ªçn
    console.log("üîπ AI Models: text-embedding-004 & gemini-2.5-flash ready.");
  }
  await listAvailableModels();

  async function extractTextFromFile(buffer, mimeType) {
    try {
      if (mimeType === 'application/pdf') return (await pdf(buffer)).text;
      if (mimeType.includes('wordprocessingml')) return (await mammoth.extractRawText({ buffer })).value;
      if (mimeType === 'text/plain') return buffer.toString('utf-8');
      return null;
    } catch (err) { throw new Error('L·ªói ƒë·ªçc file.'); }
  }

  // Chunking t·ªëi ∆∞u cho t√†i li·ªáu k·ªπ thu·∫≠t
  function chunkText(text, chunkSize = 1000, overlap = 150) {
    const chunks = [];
    let i = 0;
    while (i < text.length) {
      const end = Math.min(i + chunkSize, text.length);
      chunks.push(text.slice(i, end));
      i += (chunkSize - overlap);
    }
    return chunks;
  }

  async function createEmbedding(text) {
    const res = await genAI.models.embedContent({
      model: 'models/text-embedding-004',
      contents: [{ parts: [{ text: text }] }]
    });
    return res.values || res.embedding?.values;
  }

  async function generateContent(prompt) {
    try {
      const res = await genAI.models.generateContent({
        model: 'models/gemini-2.5-flash',
        contents: [{ parts: [{ text: prompt }] }],
        generationConfig: { maxOutputTokens: 2048, temperature: 0.7 }
      });
      return res.text || res.candidates?.[0]?.content?.parts?.[0]?.text || 'No response';
    } catch (err) { console.error('AI Gen Error:', err); throw err; }
  }

  function parseOEEQuery(question) {
    // Regex nh·∫≠n di·ªán ti·∫øng Vi·ªát & ti·∫øng Anh
    const regexA = /(?:t·ª∑ l·ªá kh·∫£ d·ª•ng|kh·∫£ d·ª•ng|availability|A)\b[^=\d:]*[=:\sl√†]\s*([\d.]+)/i;
    const regexP = /(?:hi·ªáu su·∫•t m√°y|hi·ªáu su·∫•t|performance|P)\b[^=\d:]*[=:\sl√†]\s*([\d.]+)/i;
    const regexQ = /(?:t·ª∑ l·ªá ch·∫•t l∆∞·ª£ng|ch·∫•t l∆∞·ª£ng|quality|Q)\b[^=\d:]*[=:\sl√†]\s*([\d.]+)/i;
    const matchA = question.match(regexA);
    const matchP = question.match(regexP);
    const matchQ = question.match(regexQ);
    return { 
      a: matchA ? parseFloat(matchA[1]) : null, 
      p: matchP ? parseFloat(matchP[1]) : null, 
      q: matchQ ? parseFloat(matchQ[1]) : null 
    };
  }

  function getOEEEvaluation(oee) {
    if (oee > 85) return "R·∫•t t·ªët (ƒê·∫≥ng c·∫•p th·∫ø gi·ªõi üèÜ)";
    if (oee > 60) return "T·ªët (C·∫ßn c·∫£i thi·ªán th√™m üõ†Ô∏è)";
    return "K√©m (C·∫ßn kh·∫Øc ph·ª•c ngay ‚ö†Ô∏è)";
  }

  /* ==========================================================
     üîπ API ROUTES
  ========================================================== */

  // 1Ô∏è‚É£ API Upload File
  app.post('/api/upload', upload.array('files'), async (req, res) => {
    console.log('üìÇ Processing upload...');
    if (!req.files?.length) return res.status(400).json({ error: 'No files' });
    
    try {
      for (const file of req.files) {
         const text = await extractTextFromFile(file.buffer, file.mimetype);
         if (!text) continue;
         
         // Upload file g·ªëc
         await supabase.storage.from('materials').upload(file.originalname, file.buffer, { contentType: file.mimetype, upsert: true });

         // Chunk & Embed
         const chunks = chunkText(text);
         const docs = [];
         for (const chunk of chunks) {
           const emb = await createEmbedding(chunk);
           docs.push({ file_name: file.originalname, content: chunk, embedding: emb });
         }
         await supabase.from('documents').insert(docs);
         console.log(`‚úÖ Processed: ${file.originalname}`);
      }
      res.json({ message: 'Upload th√†nh c√¥ng!' });
    } catch (err) {
      res.status(500).json({ error: err.message });
    }
  });

  // 2Ô∏è‚É£ API Chat (Trung t√¢m x·ª≠ l√Ω)
  app.post('/api/chat', async (req, res) => {
    const { question } = req.body;
    if (!question) return res.status(400).json({ error: 'Empty question' });

    try {
      // --- A. X·ª¨ L√ù LOGIC OEE ---
      if (question.toLowerCase().includes('oee')) {
        const { a, p, q } = parseOEEQuery(question);
        
        // K·ªãch b·∫£n 1: Ng∆∞·ªùi d√πng nh·∫≠p s·ªë li·ªáu tr·ª±c ti·∫øp
        if (a !== null && p !== null && q !== null) {
          const oee = (a * p * q) / 10000;
          return res.json({ answer: `üßÆ K·∫øt qu·∫£ t√≠nh to√°n:\nOEE = ${oee.toFixed(2)}%\nƒê√°nh gi√°: ${getOEEEvaluation(oee)}` });
        } 
        
        // K·ªãch b·∫£n 2: L·∫•y d·ªØ li·ªáu IoT t·ª´ DB
        else {
          console.log('üìä Fetching OEE data from Supabase...');
          const { data } = await supabase.from('OEE_Data').select('*').order('Timestamp', { ascending: false }).limit(1);
          
          if (data && data.length > 0) {
             const row = data[0];
             const oee = (row['A (%)'] * row['P (%)'] * row['Q (%)']) / 10000;
             const time = new Date(row['Timestamp']).toLocaleString('vi-VN');

             // AI Ph√¢n t√≠ch d·ªØ li·ªáu IoT
             const analysisPrompt = `
                D·ªØ li·ªáu m√°y th·ª±c t·∫ø (l√∫c ${time}):
                - A (Kh·∫£ d·ª•ng): ${row['A (%)']}%
                - P (Hi·ªáu su·∫•t): ${row['P (%)']}%
                - Q (Ch·∫•t l∆∞·ª£ng): ${row['Q (%)']}%
                => OEE Hi·ªán t·∫°i: ${oee.toFixed(2)}%

                C√¢u h·ªèi c·ªßa User: "${question}"

                H√£y ƒë√≥ng vai K·ªπ s∆∞ tr∆∞·ªüng nh√† m√°y. Tr·∫£ l·ªùi ng·∫Øn g·ªçn:
                1. B√°o c√°o t√¨nh tr·∫°ng m√°y hi·ªán t·∫°i.
                2. Nh·∫≠n x√©t nguy√™n nh√¢n n·∫øu ch·ªâ s·ªë n√†o th·∫•p.
                3. ƒê·ªÅ xu·∫•t h√†nh ƒë·ªông c·ª• th·ªÉ.
             `;
             const aiAnswer = await generateContent(analysisPrompt);
             return res.json({ answer: aiAnswer });
          } else {
             console.log('‚ö†Ô∏è No OEE data found. Falling back to docs...');
          }
        }
      }

      // --- B. X·ª¨ L√ù RAG (T√†i li·ªáu) ---
      // D√πng khi h·ªèi v·ªÅ h∆∞·ªõng d·∫´n s·ª≠ d·ª•ng, l·ªói m√°y, manual...
      const queryEmb = await createEmbedding(question);
      
      // Ng∆∞·ª°ng 0.70 l√† t·ªëi ∆∞u ƒë·ªÉ t√¨m t√†i li·ªáu ti·∫øng Anh b·∫±ng c√¢u h·ªèi ti·∫øng Vi·ªát
      const { data: docs } = await supabase.rpc('match_documents', { 
          query_embedding: queryEmb, 
          match_threshold: 0.70, 
          match_count: 5 
      });

      const context = docs.map(d => d.content).join('\n\n');
      const prompt = `
        Context:\n${context}
        
        Question: ${question}
        
        Nhi·ªám v·ª•: Tr·∫£ l·ªùi c√¢u h·ªèi d·ª±a tr√™n Context. N·∫øu kh√¥ng c√≥ th√¥ng tin trong Context, h√£y n√≥i kh√¥ng bi·∫øt.
        Tr·∫£ l·ªùi b·∫±ng Ti·∫øng Vi·ªát chuy√™n ng√†nh k·ªπ thu·∫≠t.
      `;
      const answer = await generateContent(prompt);
      res.json({ answer });

    } catch (err) {
      res.status(500).json({ error: err.message });
    }
  });

  app.listen(port, () => {
    console.log(`üöÄ Server running at http://localhost:${port}`);
    console.log(`   - Mode: ${USE_HIVEMQ_CLOUD ? 'HiveMQ Cloud' : 'Public Test Broker'}`);
  });
}

startServer().catch(err => console.error("‚ùå Server start failed:", err));